---
title: 慢SQL踩坑记录——不走索引的limit分页优化
keywords: 慢SQL 索引 分页
date:

categories: MySQL
tags:
- 数据库

---

## 背景

生产环境要对历史数据进行 {% label 归档 %}
比如2022年要对2021年的数据进行归档，简单的实现就是将创建时间小于2022-01-01的记录删除，复制到 {% label 归档库 %}
```sql
select * from table where creat_time<'2022-01-01' limit 1000
```
每次取1000条数据，复制到归档库，并删除该1000条数据
注意，字段create_time {% label 没有索引 %}

当时想法是这条SQL不存在 {% label 深度分页 %}，每次都是获取1000条数据，虽然不走索引，应该没什么大问题


## 现象

当我在生产环境执行这条sql时，发现耗时是毫秒级的，几十毫秒就返回结果。（由于没有使用索引，所以本能的要看下能不能查动）

然后解析SQL，也是没有使用索引的，符合预期

![](/images/sql/sql-limit.png)

所以就决定采用这个SQL，然后在测试环境跑了一下归档，前几千条数据很快，后面就发现归档速度 {% label 极其的慢 %}，感觉有问题

## 问题排查

由于归档的时候日志没有任何报错，只能简单看到前后两次归档的数据记录，两次间隔的时间也确实很长。
（由于归档功能是架构提供的，没有慢SQL检测，所以第一时间没有想到是SQL的问题）

于是就拿着这条SQL查询，结果查不动，一直返回不了结果。起初我还怀疑是否有 {% label 锁占用 %}。。。,一直没有正视SQL本身。

## 问题解决

后来才仔细分析了一下SQL本身。

为什么会查询很慢？ 自己问自己

由于没有使用索引，数据库在执行的时候应该是采用了聚簇索引也就是ID索引数，包含了所有字段的数据
  - 1.从第一行记录开始取。
  - 2.每取一行记录，判断下是否满足条件，是则放入结果集，否则抛弃，
  - 3.结果集条数是否大于1000，是，结束；否，继续1，2操作

![](/images/sql/v2-a8b5a8802dfc84a4db69efcbe5283be6_r.jpeg)


所以当归档开始的时候，MySQL只需要遍历1000行就结束（小于2022-01-01的数据大概一万多行），这也是为什么生产环境毫秒级的返回的原因。
但是随着数据的删除，满足条件的行数越来越少
假设满足条件的行数有10500条数据，则前10次都可以很快的返回数据，第11次的时候，会很快遍历前500条数据都符合条件，然后继续向后遍历。
此时数据库里已经没有满足条件的行了，那么会遍历到最后，也就相当于 {% label 遍历全表 %}，最后返回了500条数据。

第12次查询，也是从头遍历，遍历全表以后发现没有数据，返回0，则归档结束。

## 问题优化

给create_time创建索引，或者使用其他索引字段作为查询条件，也就是一定要使用索引

为什么使用索引就避免了慢查询呢？

使用索引可以避免全表扫描。

由于使用了索引，那么在查询的时候就会使用该字段的索引树--非聚簇索引，只有索引和ID字段（需要了解索引的存储原理）

- 1.首先MySQL会根据条件使用二分查询定位符合条件的记录，{% label 一开始就锁定了数据范围 %}
- 2.每取一行记录，回表查询
- 3.结果集条数是否大于1000，是，结束；否，继续1，2操作

这时候，第11次查询，在B+tree上，符合条件的只有500条记录了，那就返回500条记录，不会再遍历全表
这是因为B+tree利用二分查找，可以很快过滤符合条件的数据


{% note warning %}
上面的MySQL执行过程，只是一个大概原理，帮助理解，真正的执行要复杂的多而且会有很多优化
{% endnote %}


 
