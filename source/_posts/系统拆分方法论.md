---
title: 系统拆分方法论
keywords: 系统拆分 微服务拆分 微服务 架构拆分
date:

categories: 架构
tags:
- 系统拆分
- 微服务拆分

---

## 系统拆分方法论

随着业务的发展，单系统承载的业务功能越来越多，团队开发人员也在增加，将会带来一系列问题。

- 需求多，系统发布次数会增加，为了系统稳定从而要限制发布窗口，这也就会导致多个需求在同一天上线，一个功能有问题则所有的代码都要回滚
- 单系统功能业务模块较多时，A业务的代码开发可能影响B业务，比如一些公共模块的改动
- 团队人员管理方面，系统出了一些问题，到底谁来负责处理，谁来监控DB,JVM,QPS,RT等数据

-------

系统拆分可以解决大部分问题，但怎么去把代码拆出来，还是需要一些方法论支持的。

比如，**老系统的代码如何处理？新系统如何上线？两者的上下线如何保证现有功能的稳定？代码要怎么拆？如何梳理？
会不会漏了某些功能？**

我会结合空想出来的idea和实战中的具体做法去总结

--------

### 系统/微服务拆分的原则
- 1.单一职责原则
  - 按照大类拆分、业务类型拆分、模块拆分 
- 2.粒度适中原则
  - 一个接口拆一个系统出来 显然不太适合 
- 3.避免环形依赖和双向依赖
  - 理清链路调用关系，强依赖可以使用MQ解耦 
- 4.考虑团队结构
  - 我的系统我负责，每个系统分配负责人，该负责人统筹该系统的所有需求、发布上线、问题解决、监控告警等 



### 梳理拆分范围

#### 1.流量入口
- 1对外围暴露接口API
- 2.对内部暴露的controller
- 3.MQ消费  kafak/Rabbit/Rocket
- 4.job定时任务 xxl-job/spring/java定时任务
- 5.Apollo/ZK 配置变更监听 

#### 2.流量出口
- 1.API接口调用 ES查询 redis调用
- 2.MQ推送  kafak/Rabbit/Rocket
- 3.ES推送 
- 4.缓存
- 5.数据库MySQL

#### 3.架构部分
- 1.filter过滤器 登录拦截等
- 2.mybatis拦截器
- 3.AOP切面
- 4.线程池
- 5.全链路

#### 4.配置部分
- 1.YML配置
  + a. MQ kafaka Redis Apollo
  + b. consul 日志中心 Druid连接池
  + c. 框架配置 全链路
- 2.pass机器配置
- 3.CICD配置
- 4.Apollo配置
- 5.缓存配置



 
## 实操

### 代码剥离/迁移

**代码迁移有两种方案**：

- fork原来的代码库，在fork库上删除不相关代码
- 新建代码库，copy/剪切相关代码到新库中

我选择了第二种方案，我是这么考虑的

第一种方案对于环境来说比较稳妥，配置什么的都是一样的，但是我认为迁出的代码只是一小部分，
而删除的代码应该占 {% label 50%-80% %}，去判断某一块代码是否应该删除，会占用更多的精力和时间，
而分离要迁出的代码只关心哪些要剥离就好.

主要是我怕删除的时候会一不小心就删掉了一些细节，而剥离剪切更好掌控力度

{% note warning  %}
但是仔细想想，又好像没什么区别。毕竟一块代码你总要判断塔到底是否要剥离
除非你知道要剥离哪些功能，而且涉及的包或者接口你都比较清楚
事实上，你不可能全面了解一个很复杂的系统的涉及的所有业务的
{% endnote %}


刚开始操作的时候，我很天真的按照接口粒度来拆分，一个接口拆了我大概2个小时。
从API到controller到Service到实现类，此时service还没完全迁移完，我就放弃了 {% label 由于剥离的时候还想着优化一下代码占用了一点时间 %}

由于按照接口来，剪切的时候会有很多依赖类不存在，需要一个个的把依赖的类剪切过来，而且我改了包目录，
还要一个一个的import，这部分占用了大量的时间，效率是在是太慢了

-----
所以我还是选择了第一种方案，先整理下所有的接口到Excel表里，记录哪些API对应哪些业务，
整理代码功能点，然后记录是否要剥离。最后照着表格删除不用的即可

等代码整体都稳定了，然后再去定义包结构，优化模块，此时类的依赖就会随着包结构的改变而改变，不用再操心了

切忌迁移之前就定义好包目录，这样包的依赖处理会很头疼